#+title: Paradigms of Artificial Intelligence Programming Notes

* 03-PAIP
** Preface
This book is designed to help people become experts in Lisp and AI.

Has exercises labeled with four difficulty levels:

| level | meaning   | time-to-completion |
|-------+-----------+--------------------|
| s     | simple    | seconds            |
| m     | medium    | minutes            |
| h     | hard      | hours              |
| d     | difficult | days               |

** Chapter 01 - Introduction to Lisp
*** NOTES
Just the basics. If you did Touretzky's book, you don't really need to read it.

Norvig seems to prefer ~FIRST~, ~LAST~, etc. over ~CAR~ and ~CDR~. [[https://www.xach.com/naggum/articles/3092837184154309@naggum.no.html][According to Erik Naggum]], the ~LIST~ abstraction is designed to be different from the ~CONS~ abstraction, and as such, it seems ~FIRST~, ~LAST~, etc. are specific to the ~LIST~ abstraction

One thing I didn't notice while completing Touretzky's book: ~FIRST~, ~SECOND~, etc. return an atom, but ~LAST~ returns a list. ~LAST~ can return n items at the end of a list.

#+begin_src lisp
(last '(five four (three two) one))
(last '(five four (three two) one) 2)
#+end_src

#+RESULTS:
| (THREE TWO) | ONE |

** Chapter 02 - A Simple Lisp Program
*** CODE
**** Complex
#+begin_src lisp
;;; Rules:
;; Sentence => Noun-Phrase + Verb-Phrase
;; Noun-Phrase => Article + Noun
;; Verb-Phrase => Verb + Noun-Phrase
;; Article => the, a, ...
;; Noun => man, ball, woman, table...
;; Verb => hit, took, saw, liked...

;; The complex approach
;; Why is this complex?
;;; 1. The code is more complex than the rules as defined in natural language.
;;; 2. Adding new rules requires an understanding of Common Lisp semantics.
;;; You need conditionals, you need to understand DEFUN, parameter lists, APPEND, etc.

(defun sentence ()    (append (noun-phrase) (verb-phrase)))
(defun noun-phrase () (append (Article) (Noun)))
(defun verb-phrase () (append (Verb) (noun-phrase)))
(defun Article ()     (one-of '(the a)))
(defun Noun ()        (one-of '(man ball woman table)))
(defun Verb ()        (one-of '(hit took saw liked)))


(defun one-of (set)
  "Pick one element of set, and make a list of it."
  (list (random-elt set)))

(defun random-elt (choices)
  "choose an element from a list at random."
  (elt choices (random (length choices))))

(defun Adj* ()
  (if (= (random 2) 0)
      nil
      (append (Adj) (Adj*))))

(defun PP* ()
  (if (random-elt '(t nil))
      (append (PP) (PP*))
      nil))

;;; What if you don't want to use conditionals, but rely on the data-type itself?
;;; With the complex code, can't.
;; (defun Adj* ()
;;   "Warning - incorrect definition of Adjectives."
;;   (one-of '(nil (append (Adj) (Adj*))))
;;   )
                                        ; returns '(nil (append (Adj) (Adj*)))
;; (defun Adj* ()
;;   "Warning - incorrect definition of Adjectives."
;;   (one-of (list nil (append (Adj) (Adj*))))
;;   )
                                        ; infinite loop

;; Code complexity will continue to increase as more grammar rules are added. Lisp knowledge necessary for creating rules. Original code will also need to be modified to add more rules.

;; NOUN-PHRASE modified to account for optional adj and pp
(defun noun-phrase () (append (Article) (Adj*) (Noun) (PP*)))
(defun PP () (append (Prep) (noun-phrase)))
(defun Adj () (one-of '(big little blue green adiabatic)))
(defun Prep () (one-of '(to in by with on)))

(sentence)
#+end_src

#+RESULTS:
| THE | BLUE | LITTLE | BALL | BY | A | GREEN | BLUE | MAN | TOOK | THE | BIG | MAN | IN | A | TABLE |

**** Simple
#+begin_src lisp
;;; Rules:
;; Sentence => Noun-Phrase + Verb-Phrase
;; Noun-Phrase => Article + Noun
;; Verb-Phrase => Verb + Noun-Phrase
;; Article => the, a, ...
;; Noun => man, ball, woman, table...
;; Verb => hit, took, saw, liked...


;; The simple, rules-based approach. Data-driven programming.
;; Notice the similarity of the code and rules above.
(defparameter *simple-grammar*
  '((sentence -> (noun-phrase verb-phrase))
    (noun-phrase -> (Article Noun))
    (verb-phrase -> (Verb noun-phrase))
    (Article -> the a)
    (Noun -> man ball woman table)
    (Verb -> hit took saw liked))
  "A grammar for a trivial subset of English.")

(defvar *grammar* *simple-grammar*
  "The grammar used by generate.  Initially, this is
  ,*simple-grammar*, but we can switch to other grammars.")

(defun random-elt (choices)
  "choose an element from a list at random."
  (elt choices (random (length choices))))

(defun rule-lhs (rule)
  "The left-hand side of a rule."
  (first rule))

(defun rule-rhs (rule)
  "The right-hand side of a rule."
  (rest (rest rule)))

(defun rewrites (category)
  "Return a list of the possible rewrites for this category."
  (rule-rhs (assoc category *grammar*)))

(defun mappend (fn the-list)
  "Apply fn to each element of list and append the results."
  (apply #'append (mapcar fn the-list)))

;; (defun generate (phrase)
;;   "Generate a random sentence or phrase"
;;   (cond ((listp phrase)
;;          (mappend #'generate phrase))
;;         ((rewrites phrase)
;;          (generate (random-elt (rewrites phrase))))
;;         (t (list phrase))))

;; (defun generate (phrase)
;;   "Generate a random sentence or phrase. Alternate version that avoids calling (rewrites phrase) twice."
;;   (if (listp phrase)
;;       (mappend #'generate phrase)
;;       (let ((choices (rewrites phrase)))
;;         (if (null choices)
;;             (list phrase)
;;             (generate (random-elt choices))))))

;; (defun generate (phrase)
;;   "Generate a random sentence or phrase. ANSWER TO EXERCISE 2.1"
;;   (let ((choices (rewrites phrase)))
;;     (cond ((listp phrase)
;;            (mappend #'generate phrase))
;;           ((null choices) (list phrase))
;;           (t (generate (random-elt choices))))))

(defun generate (phrase)
  "Generate a random sentence or phrase. ANSWER TO EXERCISE 2.2"
  (let* ((choices (rewrites phrase))
         (terminal (null choices)))
    (cond ((listp phrase)
           (mappend #'generate phrase))
          (terminal (list phrase))
          (t (generate (random-elt choices))))))

(defparameter *bigger-grammar*
  '((sentence -> (noun-phrase verb-phrase))
    (noun-phrase -> (Article Adj* Noun PP*) (Name) (Pronoun))
    (verb-phrase -> (Verb noun-phrase PP*))
    (PP* -> () (PP PP*))
    (Adj* -> () (Adj Adj*))
    (PP -> (Prep noun-phrase))
    (Prep -> to in by with on)
    (Adj -> big little blue green adiabatic)
    (Article -> the a)
    (Name -> Pat Kim Lee Terry Robin)
    (Noun -> man ball woman table)
    (Verb -> hit took saw liked)
    (Pronoun -> he she it these those that)))

(setf *grammar* *bigger-grammar*)
;; (setf *grammar* *simple-grammar*)

(defun generate-tree (phrase)
  "Generate a random sentence or phrase,
  with a complete parse tree."
  (cond ((listp phrase)
         (mapcar #'generate-tree phrase))
        ((rewrites phrase)
         (cons phrase
               (generate-tree (random-elt (rewrites phrase)))))
        (t (list phrase))))
(generate-tree 'sentence)

;; !WARNING!WARNING!WARNING!WARNING!WARNING!WARNING!
;; When used with recursive grammar like PP*, Adj*, etc.
;; generate-all will produce an infinite loop.
;; Only use on simple grammar.
;; !WARNING!WARNING!WARNING!WARNING!WARNING!WARNING!
(defun generate-all (phrase)
  "Generate a list of all possible expansions of this phrase."
  (cond ((null phrase) (list nil))
        ((listp phrase)
         (combine-all (generate-all (first phrase))
                      (generate-all (rest phrase))))
        ((rewrites phrase)
         (mappend #'generate-all (rewrites phrase)))
        (t (list (list phrase)))))

(defun combine-all (xlist ylist)
  "Return a list of lists formed by appending a y to an x.
  E.g., (combine-all '((a) (b)) '((1) (2)))
  -> ((A 1) (B 1) (A 2) (B 2))."
  (mappend #'(lambda (y)
               (mapcar #'(lambda (x) (append x y)) xlist))
           ylist))

(defparameter *japanese-grammar*
  "Unfinished grammar for Japanese. ANSWER TO EXERCISE 2.3"
  '((sentence -> (noun-phrase verb-phrase))
    (noun-phrase -> (Noun PP* Article Adj* Noun) (Name) (Pronoun))
    (verb-phrase -> (Verb noun-phrase PP*))
    (PP* -> () (PP PP*))
    (Adj* -> () (Adj Adj*))
    (PP -> (Prep noun-phrase))
    (Prep -> に と の上に の中に で)
    (Adj -> 大きい 小さな 青い 緑の)
    (Article -> が を)
    (Name -> 恵梛 美風 マイカ 隆恵)
    (Noun -> 男性 球 女性 テーブル)
    (Verb -> 見た 好きだった 蹴った 取った)
    (Pronoun -> 彼 彼女 それ これら それら あれ)))

(setf *grammar* *japanese-grammar*)
(generate 'sentence)

#+end_src

*** EXERCISES
**** Exercise 2.1 [m] Write a version of generate that uses cond but avoids calling rewrites twice.
#+begin_src lisp
(defun generate (phrase)
  "Generate a random sentence or phrase. ANSWER TO EXERCISE 2.1"
  (let ((choices (rewrites phrase)))
    (cond ((listp phrase)
           (mappend #'generate phrase))
          ((null choices) (list phrase))
          (t (generate (random-elt choices))))))
#+end_src

**** Exercise 2.2 [m] Write a version of generate that explicitly differentiates between terminal symbols (those with no rewrite rules) and nonterminal symbols.

#+begin_src lisp
(defun generate (phrase)
  "Generate a random sentence or phrase. ANSWER TO EXERCISE 2.2"
  (let* ((choices (rewrites phrase))
         (terminal (null choices)))
    (cond ((listp phrase)
           (mappend #'generate phrase))
          (terminal (list phrase))
          (t (generate (random-elt choices))))))
#+end_src

**** PROJ Exercise 2.3 [h] Write a trivial grammar for some other language. This can be a natural language other than English, or perhaps a subset of a computer language.

**** Exercise 2.4 [m] One way of describing combine-all is that it calculates the cross-product of the function append on the argument lists. Write the higher-order function cross-product, and define combine-all in terms of it.

*** NOTES
:LOGBOOK:
CLOCK: [2024-09-15 Sun 14:48]--[2024-09-15 Sun 15:59] =>  1:11
CLOCK: [2024-09-15 Sun 07:46]--[2024-09-15 Sun 12:19] =>  4:33
:END:
**** RULES
This chapter introduces rule-based programming. Rich Hickey says that rules are simpler (and more preferable) than conditionals.

Norvig says something similar.

#+begin_quote
The program works fine, and the trace looks just like the sample derivation above, but the Lisp definitions are a bit harder to read than the original grammar rules...The problem is that the rules for Adj* and PP* contain choices that we would have to represent as some kind of conditional in Lisp...The point is that what started out as simple functions are now becoming quite complex. To understand them, we need to know many Lisp conventions-defun, (), case, if, quote, and the rules for order of evaluation-when ideally the implementation of a grammar rule should use only linguistic conventions.
#+end_quote

The point is that functions that define rules like ~noun-phrase~ need to be rewritten when adding new rules.

#+begin_quote
The two versions of the preceding program represent two alternate approaches that come up time and time again in developing programs: (1) Use the most straightforward mapping of the problem description directly into Lisp code. (2) Use the most natural notation available to solve the problem, and then worry about writing an interpreter for that notation.

Approach (2) involves an extra step, and thus is more work for small problems. However, programs that use this approach are often easier to modify and expand.
#+end_quote

The second, simple approach of using a rule-based, data-driven approach leads to code that is more extensible. Norvig doesn't say it, but I think it is probably more "composable".

The addition of a larger grammar demonstrates how easy it is to extend the grammar. No need to modify previously defined functions like ~generate~ or write some function named ~Prep~.

The simpler version also allows us to easily add features without modifying many disparate functions or files.

**** INTRODUCING AND USING VARIABLES
#+begin_quote
let is the most common way of introducing variables that are not parameters of functions. One must resist the temptation to use a variable without introducing it:

(defun generate (phrase)
  (setf choices ...)         ;; wrong!
  ... choices ...)
#+end_quote

Here we see the expression "introducing variables".


** Chapter 03 - Overview of Lisp
*** EXERCISES
**** Exercise 3.1 [m] Show a lambda expression that is equivalent to the above let* expression. You may need more than one lambda.
#+begin_src lisp
(let* ((x 6)
       (y (* x x)))
  (+ x y))

(funcall (lambda (a b) (+ a b))
         6
         (funcall (lambda (y) (* y y)) 6))
#+end_src

#+RESULTS:
: 42

**** Exercise 3.2 [s] The function cons can be seen as a special case of one of the other functions listed previously. Which one?
push
**** Exercise 3.3 [m] Write a function that will print an expression in dotted pair notation. Use the built-in function princ to print each component of the expression.
**** Exercise 3.4 [m] Write a function that, like the regular print function, will print an expression in dotted pair notation when necessary but will use normal list notation when possible.
**** Exercise 3.5 [h] (Exercise in altering structure.) Write a program that will play the role of the guesser in the game Twenty Questions. The user of the program will have in mind any type of thing. The program will ask questions of the user, which must be answered yes or no, or "it" when the program has guessed it. If the program runs out of guesses, it gives up and asks the user what "it" was. At first the program will not play well, but each time it plays, it will remember the user's replies and use them for subsequent guesses.
**** Exercise 3.6 [s] Given the following initialization for the lexical variable a and the special variable *b*, what will be the value of the let form?
#+begin_src lisp
(setf a 'global-a)
(defvar *b* 'global-b)

(defun fn () *b*)

(let ((a 'local-a)
      (*b* 'local-b))
  (list a *b* (fn) (symbol-value 'a) (symbol-value '*b*)))
#+end_src

#+RESULTS:
| LOCAL-A | LOCAL-B | LOCAL-B | GLOBAL-A | LOCAL-B |

**** Exercise 3.7 [s] Why do you think the leftmost of two keys is the one that counts, rather than the rightmost?
They're read first.
**** Exercise 3.8 [m] Some versions of Kyoto Common Lisp (KCL) have a bug wherein they use the rightmost value when more than one keyword/value pair is specified for the same keyword. Change the definition of find-all so that it works in KCL.
*** NOTES
:LOGBOOK:
CLOCK: [2024-09-16 Mon 17:01]--[2024-09-17 Tue 13:59] => 20:58
:END:

**** 3.1 A GUIDE TO LISP STYLE
#+begin_quote
Be specific.
Use abstractions.
Be concise.
Use the provided tools.
Don't be obscure.
Be consistent.
#+end_quote

There are some specific parts of Lisp here that weren't covered in Touretzky (DEFINE-SETF-METHOD, DEFSETF, etc.), and it has very useful comparison charts showing comparisons between Common Lisp and Pascal. I see them, plus [[https://www.norvig.com/python-lisp.html][Norvig's own comparison]] to Python, as a great starting point for comparing Python and JS in the masterclass.
**** SPECIAL FORMS
| definitions  | conditional | variables | iteration | other    |
|--------------+-------------+-----------+-----------+----------|
| defun        | and         | let       | do        | declare  |
| defstruct    | case        | let*      | do*       | function |
| defvar       | cond        | pop       | dolist    | progn    |
| defparameter | if          | push      | dotimes   | quote    |
| defconstant  | or          | setf      | loop      | return   |
| defmacro     | unless      | incf      |           | trace    |
| labels       | when        | decf      |           | untrace  |

** Chapter 04 - GPS: The Genera Problem Solver
** Chapter 05 - ELIZA: Dialog with a Machine
** Chapter 06 - Building Software Tools
** Chapter 07 - STUDENT: Solving Algebra Word Problems
** Chapter 08 - Symbolic Mathematics: A Simplification Program
** Chapter 09 - Efficiency issues
** Chapter 10 - Low-Level Efficiency Issues
** Chapter 11 - Logic Programming
** Chapter 12 - Compiling Logic Programs
** Chapter 13 - Object-Oriented Programming
** Chapter 14 - Knowledge Representation and Reasoning
** Chapter 15 - Symbolic Mathematics with Canonical Forms
** Chapter 16 - Expert Systems
** Chapter 17 - Line-Diagram Labeling by Constraint Satisfaction
** Chapter 18 - Search and the Game of Othello
** Chapter 19 - Introduction to Natural Language
** Chapter 20 - Unification Grammars
** Chapter 21 - A Grammar of English
** Chapter 22 - Scheme: An Uncommon Lisp
** Chapter 23 - Compiling Lisp
** Chapter 24 - ANSI Common Lisp
** Chapter 25 - Troubleshooting
